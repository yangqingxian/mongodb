这里先讲几件事：
1、这是第三次修改这篇文章了，也是第一次正真意义上的使用 github 来控制版本，想想还是有点小激动的:)
2、其中的内容结构与 mongodb基础命令是一致的，只不过添加了很多内容进去，适用于想进一步学习mongodb数据库的人
3、我其实也是菜鸟，所以我会用很白目的语言来解释其中的内容，如果你也跟我一样，那就两只鸟一起飞吧
4、接下来的内容均是我对《MongoDB大数据权威指南(第2版)》的摘记
5、其中的命令例子并没有事先创建好数据库、集合，都是要用到的时候临时写的，注意理解

mongodb数据库结构与传统关系型数据库的比较，便于理解接下来的内容
数据库->集合->文档
数据库->表  ->列

--------------------------------------------------数据库内容---------------------------------------------
查看所有数据库
show dbs

删除数据库
db.dropDatebase()
--------------------------------------------------集合内容-----------------------------------------------
创建集合
db.createCollection()

查看所有集合\表
show collections
show tables

选定某一集合
use db_name

查看集合的信息
db.stats()

删除一个集合，但是需要先指定一个数据库，即先执行 use db_name
db.dropDatabase()

修改集合的名称
db.collection_name.renameCollection('new_name')

-------------------------------------------------文档内容------------------------------------------------
插入数据
db.collection_name.insert(document)
db.collection_name.save(document)

查询数据多条数据
db.collection_name.find()
-------------------------
1、可以指定返回的内容
参数解释
db.collection_name.find(
	{query_term:value},
	return_key_name:1}
)
a find()函数的第一个参数是查询条件，即匹配该内容的文档都会被筛选出来
b find()函数的第二个参数是指定返回的内容，例如一个student的集合中的一个xiaoming文档中包含多条内容，姓名、学生号、家庭住址等，现在我只想看姓名，不想查询的时候返回xiaoming文档的全部内容，就可以使用这种'键名:1'的形式，后面的1表示筛选出该内容并正序输出，0表示筛选出除了该内容的其余部分，-1表示逆序跟1一样的结果
c 可以返回多条记录，这里只是举个例子，还是拿ixaoming的例子
{
	'name':1,
	'student_id':1
}
这样就返回了两个信息，一个name，一个student_id
2、查询嵌套信息
结合二维数组理解下面的这个信息
{
	'name':'yang',
	'sex':'man',
	'skill':[
		{'php':1},
		{'mongodb':4},
		{'redis':5}
	],
	'favorite_food':'meat'
}
其中如果使用skill来作为find()的查询条件的话，千万别写成这样
---错误例子---
db.self.find({'skill':[{'php':1}]})
这样是查不到的，因为这样mongodb会将{'skill':[{'php':1}]}解析成skill数组下只包含'php':1这一条记录的内容，上面的例子明显不符合这一要求，所以查询不到
---正确的例子---
db.self.find({'skill.php':1})
这里使用了 . 告诉mongodb数据库去匹配skill数组下php为1的内容，重点在于skill下是否有'php':1这一条记录
---正确例子2---
如果一定要使用上面的错误例子的方式查询数据，可以使用$elemMatch参数，注意该参数使用的位置
db.self.find({
	'skill':{$elemMatch:
	{'php':1}
	}
})


查询单条数据
db.collection_name.findOne()

skip 跳过查询的最开始的数量，limit，限制返回数量，sort，当 x:1 表示正序，x:-1 表示逆序
db.collection_name.find().skip(Number).limit(Number).sort({x:1})

计算符合查询条件的文档的数量
db.collection_name.find().count()
---------------------------------
count()函数默认情况下会忽略skip()或limit()函数，例如假设student集合中有4个文档，下面的三条语句将显示不同的结果
db.student.find().limit(1).count() 		结果为4，count忽略了limit(1)的条件
db.student.find().limit(1).count(true)	结果为1，为count()传入参数true

获取结果的唯一值
db.collection_name.distinct('key_name')
-----------------------------
也是查询的函数，只不过他比起find()会将查询结果显示唯一值，而不是根据原有集合中，文档的数量来显示结果，结合关系
型数据库中的distinct来理解，举个例子，有一个图书集合--books，该集合下有书名，作者，出版日期等信息，注意，一个作者可能写了很多本书，现在我想查看在该集合中有多少作者，如果我直接使用上面的find()函数来搜索的话
db.books.find(
	{},
	{'writer':1}
)
这样会将全部的作者列出来，但是很多都是重复的，因为find()是根据文档数量来返回结果的，而distinct()会将结果筛选，
其中重复的部分
db.books.distinct('writer')

将查询结果分组
db.collection_name.group()
--------------------------
传入参数1 key 按照该键进行分组
传入参数2 initial 统计分组后各个组的数量
传入参数3 reduce 他又可以接收两个参数，正在遍历的当前文档和聚集计数器对象，具体的可以去看接下来展示的例子
传入参数4 keyf 书上没有例子，理解不能
传入参数5 cond 指定参与分组的文档需要满足的要求
传入参数6 finalize 指定一个函数，在分组完成后会自动执行
可能比较难理解，那么请看下面这个例子，这个例子只使用到了前3个参数，假设一订单集合，现使用group()来统计各用户订
单情况
db.order.group(
{
	key:{CustomerID:true},//按照用户的id来分组
	initial:{Total:0},	  //计算每个用户分别下了多少订单
	reduce:function(item,prev){
		//这里的item就是当前文档，prev就是聚集计数器对象
	}
})

----------------------------------------使用条件操作符来筛选查询结果---------------------------------------
一般情况下都使用在find()的第一个参数内部，作为筛选条件使用

---$gt,$lt,$get,$lte,$ne---
db.collection_name.find(
{
	key_name:{$gt:value}
})
注意操作符的位置，看例子可以便于理解
db.student.find(
{
	'height':{$gt:180}
})
表示筛选出学生集合中身高高于180的学生
可以同时使用两个操作符来指定范围
db.student.find({
	'height':{$gt:180,$lt:220}
})

这两个的使用方法跟上面是一样的，但是需要单独拎出来讲，因为有点特殊
---$in,$nin---
db.student.find({
	'height':{$in:[170,180,190,200]}
})
表示筛选出身高为170，180，190，200的学生，$nin就是筛选除了170，180，190，200之外的学生
---$all---
上面的$in中的内容是‘或’的形式，只要你的身高是170，或180，或190，或200，那么你就符合筛选条件，而$all则是且的关系
db.student.find({
	'height':{$all:[170,180,190,200]}
})
这句话的意思是你的身高既是170，又是180，又是190，又是200才能满足条件

---$or---
db.student.find({
	$or:[
		{'score':100},
		{'sex':man}
	]
})
上面的例子中，score:100与sex:man是‘或’的关系，结合下面的例子就可以看出$or的作用了
db.student.find(
	{'score':100,'sex':'man'}
)
其中的score:100与sex:man是且的关系

limit(x)函数加skip(y)函数=$slice:[y,x]
具体使用方法可以看下面这个例子
db.student.find(
{},
{'height':{$slice:[10,5]}}
)
还是那句老话，注意$slice的位置，这句话表示筛选身高第11到15的人，第一个参数是skip()的参数，第二个是limit()

limit()函数是限制返回文档的数量的，$size是筛选符合数量的数组的，看下面的例子就明白了
先在数据库中添加以下信息
------------------------
message={
	'cds':[
	{'first_song':'hello'},
	{'second_song':'world'},
	{'third_song':'again'}
	]
}
db.songs.insert(message)
------------------------
接着我们来查询一下上述结果
db.songs.find(
{'cds':{$size:2}}
)
无返回结果，因为cds数组里有3组数据
db.songs.find(
{'cds':{$size:3}}
)
返回全部结果，注意一点，这里是作为find()函数的第一个参数传入的，所以是筛选条件

筛选含有特定字段的值
db.collection_name.find(
{
	key_name:{$exit:true}
})
-------------------------
返回存在该字段的文档，注意，这里是存在该字段，而没有指定该字段的具体内容

根据数据类型筛选返回结果
db.collection_name.find(
{
	'key_name':{$type:x}
})
-------------------------
其中的x取值内容有很多，这里就不介绍了，因为太多了看一遍也没用

在筛选中使用正则表达式
db.collection_name.find(
{
	'key_name':/ /
})
-------------------
在/ /中添加正则表达式的内容

-------------------------------------------------------------------------------------------------------------

更新数据
db.collection_name.update({original_key:original_value},{new_key:new_value})
----------------------------------------------------------------------------
1、只要原 collection 中包含 original_key:original_value 就会被选中成为操作对象
2、整个 collection 都会被更新成 new_key:new_value ，而不单单就只是更新 original_key:original_value

相较于上面会更新整个集合，下面添加了 $set: 的形式来只进行部分字段的更新
db.collection_name.update({original_key:original_value},{$set:{new_key:new_value}})

上面使用$set更新了一条字段，可以使用$unset删除一条字段
db.collection_name.update{
	{},
	{$unset:{key:value}}
}

如果此更新数据不存在就创建这一条数据，加第三个参数为 true 就可以实现了
db.collection_name.update({original_key:original_value},{new_key:new_value},true)
或者下面的形式也可以
db.collection_name.update({original_key:original_value},{new_key:new_value},{upsert:true})

update 只会更新第一条满足条件的记录，但是想更新多条记录时，将第三个参数设置为 false，第四个参数设置为 true，而且还要设置 $set
db.collection_name.update({original_key:original_value},{$set{new_key:new_value}},false,true)

---------------------------------------插入数据——数组部分--------------------------------------------
插入数据
db.collection_name.update(
{original_key:value},
{$push:{
	new_key:new:value
}}
)
--------------------------
注意，如果original_key不存在，则会被创建，并且定义为数组的形式，new_key:value则是第一个值
如果original_key存在，并且数数组，则插入new_key:value，如果不是数组，则报错

一次性插入多个值，前面是使用$push一次插入一个值，如果想插入多个值的话，需要使用下面的内容
db.collection_name.update(
{original_key:value},
{$push:{
	new_key:{
		$each:[
			'value1',
			'value2',
			'value3'
		]
	}
}
})
注意这里的$push是针对数组操作的，也就是$each后面的内容都将添加到new_key的数组中

与$push对应，$pop删除数组中的数据
db.collection_name.update(
{original_key:value},
{$pop:{
	{original_key:1}
}
})
--------------------------
注意，这里的1表示删除的数量，可以是2，3等整数，表示从数组的后端开始删除，也可以是-1等负数，表示从数组的前端开始删除

前面的$pop可以指定删除的数量，但是不能指定删除的条件，$pull则可以
db.collection_name.update(
{original_key:value},
{$pull:
	{key1:value1}
}
)
--------------------------
$pull会删除掉key1中所有value1的数据，注意，是删除key1中的value1数据，不是删除key1，所以只要key1数组中包含了value1就会被删除掉value1

与$pull类似，$pullAll可以删除掉多个数据
db.collection_name.update(
{original_key:value},
{$pullAll:{
	key1:
	[
		'value1',
		'value2',
		'value3'
	]
}
})

$addToSet是一个非常实用的向数组添加数据的命令，如果该数据不存在则添加，存在就不会重复添加了
db.collection_name.update(
{original_key:value},
{$addToSet:{
	new_key:{
		$each:[
			'value1',
			'value2',
			'value3'
		]
	}
}
})
设想一下，如果这里不添加$each的情况，如果不添加$each,则会变成往数组new_key中直接添加新的数组
['value1','value2','value3']
可以尝试一下，理解$each的功能，回到$addToSet上来，如果原数组中就存在value1,value2,value3则不会添加，如果不存在，则将没有的添加进去，有的也不会重复添加，彼此之间不是互相影响的。
--------------------------------------------------------------------------------------------------------------

原子操作
这里就不解释什么叫原子操作了，对于我们使用者来说只要知道怎么采用原子操作就可以了
db.collection_name.findAndModify(
	{
	query:{key:value},
	sort:{key2:1/-1},
	update/remove:true,
	new:true
	}
)
-----------------------
query 指定查询的文档
sort  排序，1，-1的含义这里就不解释了，跟上面一样
update/remove 表示操作
new  表示返回最终的修改结果，可以不填

删除所有查找到的数据
db.coolection_name.remove({key:value})

删除一张表
db.collection_name.drop()

查看集合的索引
db.collection_name.getIndexes()

创建索引
db.collection_name.ensureIndex({key:value})

前面是根据key:value的形式创建索引的，接下来就为一集合的某一字段全部创建索引
db.collection_name.ensureIndex({key:1})
---------------------------------------
复合索引的创建就是在其中多添加几个内容

删除索引
db.collection_name.dropIndex({key:value})

删除所有索引
db.collection_name.dropIndexes()
